/*
 * Stringtest.c
 */
#include "common.h"
#include "operations.h"

/* (TBD)(INT_QUEST)https://www.careercup.com/question?id=14424684 */
char *read4k(char *buf, int num) {
	return NULL;
}

/* Given a string as ipv4 convert to an integer, also check if it is Valid 
 * Eg: 256.0.0.1 return 0 as it is invalid
 * */
int32_t convertIP1(char *ipstr)
{
    uint32_t v = 0;
    int i;
    int sum;
    char *ptr = ipstr;
    for (i=0; i <4 ;i++) {
         char c;
         sum = 0;
         while (1) {
             c = *ptr;
             ptr++;
             if (c >= '0' && c <='9') {
                    sum *= 10;       
                    sum += c - '0' ;
             } else if(((i< 3) && c == '.') || i == 3) {
                  break;
             }
               else  {
                 return 0;
             }
             
         } 
         if (sum >= 256)
               return 0;
    
         v *= 256;
         v += sum;

    }
    return v;
}
int32_t convertIP2(char *ipstr) {
    int a, b, c, d;
    int v = 0;
    if (scanf("%u.%u.%u.%u", &a, &b, &c, &d) < 4)
	return 0;
    return v;   
}
/* 
 * Given two string str and bucket ,
 * return true if str can be constructed from bucket return false if str can't be constructed from bucket
 * Eg: str=”abc321$%55” and bucket=”5cba213$%5tt” true , str=”abc321$%55” and bucket=”cba213$%5tt”, return false 
 * calculate number of occurance characters in bucket and then compare it with str]*/
 int strbuck(const char *str, const char *bucket) {
     ulong hash[256];
     char *p;
     
     if (str == NULL)
         return 1;
     if (bucket == NULL)
         return 0;
	 
     /* Calculate number of character occurence in bucket */	 
     p = (char *)bucket;
     while (*p != '\0') {
	 hash[*p]++;
	 p++;
     }
     /* Compare hash occurences with string */
     p = (char *)str;
     while(*p != '\0') {
	 if (hash[*p] == 0)
	     return 0;
	 hash[*p]--;
	 p++;
     }
     return 1;
 }


/* Given two strings s and t which consist of only lowercase letters.
String t is generated by random shuffling string s and then add one more letter at a random position.
Find the letter that was added in t 
Eg: s="abcd" , t ="cdbea" return e
* https://leetcode.com/problems/find-the-difference/description/ 
**/

char findDifferene(char *s, char *t) {
    int s_l = strlen(s);
    int t_l = strlen(t);
    int s_t , t_t, i;
    s_t = t_t = 0;
    
    if (!s_l || !t_l) {
        return 0;
    }
    for (i = 0; i < s_l; i++) {
       s_t += (s[i] - 'A');
       t_t += (t[i] - 'A');
    } 
    t_t += (t[i] - 'A');
    return (char )((t_t - s_t) +'A');
}
/* Find if s1 is subsequence of s2 
 * Input: str1 = "AXY", str2 = "ADXCPY"
 * Output: True (str1 is a subsequence of str2)
 *
 * Input: str1 = "AXY", str2 = "YADXCP"
 * Output: False (str1 is not a subsequence of str2)
 *
 * Input: str1 = "gksrek", str2 = "geeksforgeeks"
 * Output: True (str1 is a subsequence of str2)
 */
int isSubsequence(char s1[], char s2[]) {
	char *str1 = s1;
	char *str2 = s2;
	while((*str1 != '\0') && (*str2 != '\0')) {
		if (*str1 == *str2) {
			str1++;
			str2++;
		} else 
			str2++;
	} 
	if (*str1 == '\0')
		return 1;
	return 0;
}

/* Multiply integers represented as strings */
char *multiplyStrings(char *num1, char *num2) {
	char *num3;
    if (!num1 || !num2) {
        return NULL;
    }
    
    int l_1 = strlen(num1);
    int l_2 = strlen(num2);
    int i , j;
    int len = l_1 + l_2;
    
    num3 = (char *)calloc(1, len);
    log ("multiply(%s:%s) ",num1, num2);
    for (i = (l_1 - 1); i >= 0 ; i--) {
        int carry = 0;
        for (j =(l_2 - 1); j >= 0; j--) {
            int mul = (num1[i] - '0') * (num2[j] - '0') + carry + num3[i+j+1];
            num3[i+j+1] = (mul % 10);
            carry = (mul / 10);
            log ("num3 (%d,%d,%d) (%d,%d)\n",num3[i+j+1], carry, mul, i, j);
        }
        num3[i] += carry; 
    }
    int k = 0, t=0;
    /* remove zero's at startif any */
    while ((k < (len-1)) && (num3[k] == 0))
        k++; 
    
    char *ans = (char *)calloc(1, (len - k +1));
    for (; k < len ;k++) {
        log ("(%d:%d:%d:%d) \n", k, t, num3[k],len);
        ans[t++] = num3[k] + '0';
    }
    ans[t] ='\0';
    free(num3);
    return ans;
}


/* Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.
    Both num1 and num2 contains only digits 0-9. Both num1 and num2 does not contain any leading zero.
    You must not use any built-in BigInteger library or convert the inputs to integer directly.
    Logic: Start from end of the strings and add digits */

char* addStrings(char* num1, char* num2) {
    char *num3;
    int l1 = strlen(num1);
    int l2 = strlen(num2);
    int carry = 0;
    if (!l1)
        return num2;
    if (!l2)
        return num1;
    int size = max(l1,l2) +1; /* 1 for carry */
    int k;
    num3 = (char *)calloc(1, size);
    l1--;
    l2--;
    
    k = size-1;
    while ((l1 >= 0) || (l2 >=0)) {
        int sum = carry ;
        if (l1 >= 0) {
            sum += num1[l1] - '0';
            l1--;
        }
        if (l2 >= 0) {
            sum += num2[l2] - '0';
            l2--;
        }
        num3[k] = (sum %10) + '0';
        carry = (sum / 10);
        k--;
        
    }
    log("carry%d k%d size:%d) \n",carry, k, size);
    if (carry) {
        num3[k] = carry + '0';
        log ("num3(%s) size(%d)\n",num3, size);
        return num3;
    } else { /* readjust num3 */
        char *num4 = calloc(1, size - 1);
        log ("num3(%s) size:%d\n",num3, size-1);
        for (k=1;k<size;k++) {
            num4[k-1] = num3[k];
        }
        log ("num3(%s) num4(%s)\n",num3, num4);
        free(num3);
        return num4;
    }
}

/* Compare two versions like 1.2 , 1.13 and return 1 if version 1 is bigger 
 * and -1 if version1 is smaller or 0 
 */ 
int compareVersion(char* version1, char* version2) {
    int l1 = strlen(version1);
    int l2 = strlen(version2);
    int i =0 , j=0;
    while ((i < l1) || (j<l2)) {
        long long int num1=0, num2=0;
        while ((i<l1)&& version1[i] != '.') {
            num1 += num1*10 + (version1[i] - '0');
            i++;
        }
        while ((j<l2) && version2[j] != '.') {
            num2 += num2*10 + (version2[j] - '0'); 
            j++;
        }
        log("Sum(%lld:%lld) \n",num1,num2);
        if (num1 < num2) 
            return -1;
        else if (num1 > num2)
            return 1;
        if ((version1[i] != '\0') && (version1[i] == '.')) i++;
        if ((version2[j] != '\0') && (version2[j] == '.')) j++;
    }
    
    return 0;
}
/* atoi function convert string to integer 
 https://leetcode.com/problems/string-to-integer-atoi/#/description
 */
int myAtoi(char* str) {
    if (str == NULL)
        return 0;
    long long int i =0, len = strlen(str);
    int sign = 1, sum =0;
    
    while (str[i] != '\0' && str[i] == ' ')
            i++;
    if (str[i] != '\0') {
        if (str[i] ==  '+') {
            sign = 1;
            i++;
        } else if (str[i] == '-')  {
            sign = -1;
            i++;
        }
        while ((str[i] != '\0') && isdigit(str[i])) {
            int n = sum;
            sum = (sum * 10) + (str[i] - '0');
            if (sum/10 != n) {/* number too large or small */
                if (sign < 0)
                    return INT_MIN;
                else
                    return INT_MAX;
            }
            //log ("sum(%d) %d \n",sum, str[i]);
            i++;
        }
    
    }
    return (sign * sum);
}
char isUpper(char s) {
    if (s >= 'A' && s <= 'Z')
        return 1;
    return 0;
}
/* Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.
https://leetcode.com/submissions/detail/180709866/ 
Input: "Hello"
Output: "hello"
*/

char* toLowerCase(char* str) {
    int len = strlen(str);
    int i = 0;
    char *result = malloc(len * sizeof(char));
    
    if (result == NULL)
        return NULL;
    
    while (i < len) {
        if (isUpper(str[i]))
            result[i] = str[i] - 'A' + 'a';
        else 
            result[i] = str[i];
        i++;
    }
    result[i] = '\0';
    return result;
}
#define MAX_ASCII 256
/* Remove duplicates in a string */
void removeDups(char *str) {
	int len = strlen(str);
	int hash[MAX_ASCII];
	int i, j;

	if (str == NULL || str[0] == '\0')
		return;

	for (i = 0; i < MAX_ASCII; i++)
		hash[i] = -1;
	i = j = 0;
	while (i < len) {
		if (hash[str[i]] != -1 ) { /*skip letter */
			i++;
		} else {
			hash[str[i]] = i; /*save index */
			str[j++] = str[i++];
		}
	}
	if (j != len)
		str[j] = '\0';
}
			
void start_stringtest(int argc, char *argv[]) {
	log ("num of arguments %d",argc);
	
	if (argc <= 3) {
		log_err("Usage: <stringtests> <arg>");
		return ;
	}
	
	if ((strcmp(argv[2],"multiply") == 0) && (argc >= 5)) {
			char *result = multiplyStrings(argv[3], argv[4]);
			log ("(%s:%s)", argv[2], argv[3]);
			if (result) {
				printf("mulitply(%s:%s) is %s \n", argv[3], argv[4], result);
				free(result);
			}
	} else if ((strcmp(argv[2],"add") == 0) && (argc >= 5)) {
			char *result = addStrings(argv[3], argv[4]);
			log ("Test (%s:%s)", argv[3], argv[4]);
			if (result) {
				printf("addString of (%s:%s) is %s \n", argv[3], argv[4], result);
				free(result);
			}
	} else if ((strcmp(argv[2],"removeDups") == 0) && (argc >= 4)) {
			char *before = malloc(strlen(argv[3]));
			strcpy(before, argv[3]);
			removeDups(argv[3]);
			log ("Test (%s:%s)", before, argv[3]);
			printf("removeDups of (%s) == %s \n", before, argv[3]);
			free(before);
	} else if ((strcmp(argv[2],"finddiff") == 0) && (argc >= 5)) {
			char result = findDifferene(argv[3], argv[4]);
			log ("Test (%s:%s)", argv[3], argv[4]);
			if (result) {
				printf("difference of (%s:%s) is %c \n", argv[3], argv[4], result);
			}
	} else if (strcmp(argv[2], "compvers") == 0) {
			int result = compareVersion(argv[3], argv[4]);
			printf("compare(%s:%s) result%d\n", argv[3], argv[4], result);
	} else if (strcmp(argv[2], "atoi") == 0) {
		       int result = myAtoi(argv[3]);
		       printf ("atoi(%s) == %d \n", argv[3], result);
	} else {
		log_err("Usage: <tests> <>");
	}
}

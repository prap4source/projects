/*
 * Stringtest.c
 */
#include "common.h"
#include "operations.h"
/* (TBD)(INT_QUEST)https://www.careercup.com/question?id=14424684 */
char *read4k(char *buf, int num) {
	return NULL;
}

/* Given a string as ipv4 convert to an integer, also check if it is Valid 
 * Eg: 256.0.0.1 return 0 as it is invalid
 * */
int32_t convertIP1(char *ipstr)
{
    uint32_t v = 0;
    int i;
    int sum;
    char *ptr = ipstr;
    for (i=0; i <4 ;i++) {
         char c;
         sum = 0;
         while (1) {
             c = *ptr;
             ptr++;
             if (c >= '0' && c <='9') {
                    sum *= 10;       
                    sum += c - '0' ;
             } else if(((i< 3) && c == '.') || i == 3) {
                  break;
             }
               else  {
                 return 0;
             }
             
         } 
         if (sum >= 256)
               return 0;
    
         v *= 256;
         v += sum;

    }
    return v;
}
int32_t convertIP2(char *ipstr) {
    int a, b, c, d;
    int v = 0;
    if (scanf("%u.%u.%u.%u", &a, &b, &c, &d) < 4)
	return 0;
    return v;   
}
/* 
 * Given two string str and bucket ,
 * return true if str can be constructed from bucket return false if str can't be constructed from bucket
 * Eg: str=”abc321$%55” and bucket=”5cba213$%5tt” true , str=”abc321$%55” and bucket=”cba213$%5tt”, return false 
 * calculate number of occurance characters in bucket and then compare it with str]*/
 int strbuck(const char *str, const char *bucket) {
     ulong hash[256];
     char *p;
     
     if (str == NULL)
         return 1;
     if (bucket == NULL)
         return 0;
	 
     /* Calculate number of character occurence in bucket */	 
     p = (char *)bucket;
     while (*p != '\0') {
	 hash[*p]++;
	 p++;
     }
     /* Compare hash occurences with string */
     p = (char *)str;
     while(*p != '\0') {
	 if (hash[*p] == 0)
	     return 0;
	 hash[*p]--;
	 p++;
     }
     return 1;
 }


/* Given two strings s and t which consist of only lowercase letters.
   String t is generated by random shuffling string s and then add one more letter at a random position.
   Find the letter that was added in t Eg: s="abcd" , t ="cdbea" return e
   https://leetcode.com/problems/find-the-difference/description/ 
*/
int findDifference(char *s, char *t) {
    int s_l = strlen(s);
    int t_l = strlen(t);
    int s_t , t_t, i;
    s_t = t_t = 0;
    
    if (!s_l || !t_l) {
        return 0;
    }
    for (i = 0; i < s_l; i++) {
       s_t += (s[i] - 'A');
       t_t += (t[i] - 'A');
    } 
    t_t += (t[i] - 'A');
    printf("Difference of (%s:%s) is %c \n", 
		    s, t, (char )((t_t - s_t) +'A'));
    return 0;
}

/* Find if s1 is subsequence of s2 
 * Input: str1 = "AXY", str2 = "ADXCPY"
 * Output: True (str1 is a subsequence of str2)
 *
 * Input: str1 = "AXY", str2 = "YADXCP"
 * Output: False (str1 is not a subsequence of str2)
 *
 * Input: str1 = "gksrek", str2 = "geeksforgeeks"
 * Output: True (str1 is a subsequence of str2)
 */
int isSubsequence(char *s1, char *s2) {
	char *str1 = s1;
	char *str2 = s2;
	bool isSub = 0;
	while((*str1 != '\0') && (*str2 != '\0')) {
		if (*str1 == *str2) {
			str1++;
			str2++;
		} else 
			str2++;
	} 
	if (*str1 == '\0') 
		isSub = 1;
	printf("%s is %s of %s \n", 
		s1, (isSub) ? "subsequence": "not subsequence", s2);
	return 0;
}

/* Multiply integers represented as strings */
char *multiplyStringsHelper(char *num1, char *num2) {
    char *num3;
    int l_1 = strlen(num1);
    int l_2 = strlen(num2);
    int i , j;
    int len = l_1 + l_2;
    

    num3 = (char *)calloc(1, len);
    log ("multiply(%s:%s) ",num1, num2);
    for (i = (l_1 - 1); i >= 0 ; i--) {
        int carry = 0;
        for (j =(l_2 - 1); j >= 0; j--) {
            int mul = (num1[i] - '0') * (num2[j] - '0') + carry + num3[i+j+1];
            num3[i+j+1] = (mul % 10);
            carry = (mul / 10);
            log ("num3 (%d,%d,%d) (%d,%d)\n",num3[i+j+1], carry, mul, i, j);
        }
        num3[i] += carry; 
    }
    int k = 0, t=0;
    /* remove zero's at startif any */
    while ((k < (len-1)) && (num3[k] == 0))
        k++; 
    
    char *ans = (char *)calloc(1, (len - k +1));
    for (; k < len ;k++) {
        log ("(%d:%d:%d:%d) \n", k, t, num3[k],len);
        ans[t++] = num3[k] + '0';
    }
    ans[t] ='\0';

    /* Free memory ans will be freed by caller*/
    free(num3);

    return ans;
}
int multiplyStrings(char *str1, char *str2){
	char *result;

	if (!str1 || !str2)
		return 1;
	result = multiplyStringsHelper(str1, str2);
	if (result) {
		printf("multiplyString of (%s:%s) is %s \n", str1, str2, result);
		free(result);
	}

	return 0;
}

/* Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.
    Both num1 and num2 contains only digits 0-9. Both num1 and num2 does not contain any leading zero.
    You must not use any built-in BigInteger library or convert the inputs to integer directly.
    Logic: Start from end of the strings and add digits */
char* addStringsHelper(char* num1, char* num2) {
    char *num3;
    int l1 = strlen(num1);
    int l2 = strlen(num2);
    int carry = 0;
    if (!l1)
        return num2;
    if (!l2)
        return num1;
    int size = max(l1,l2) +1; /* 1 for carry */
    int k;
    num3 = (char *)calloc(1, size);
    l1--;
    l2--;
    
    k = size-1;
    while ((l1 >= 0) || (l2 >=0)) {
        int sum = carry ;
        if (l1 >= 0) {
            sum += num1[l1] - '0';
            l1--;
        }
        if (l2 >= 0) {
            sum += num2[l2] - '0';
            l2--;
        }
        num3[k] = (sum %10) + '0';
        carry = (sum / 10);
        k--;
        
    }
    log("carry%d k%d size:%d) \n",carry, k, size);
    if (carry) {
        num3[k] = carry + '0';
        log ("num3(%s) size(%d)\n",num3, size);
        return num3;
    } else { /* readjust num3 */
        char *num4 = calloc(1, size - 1);
        log ("num3(%s) size:%d\n",num3, size-1);
        for (k=1;k<size;k++) {
            num4[k-1] = num3[k];
        }
        log ("num3(%s) num4(%s)\n",num3, num4);
        free(num3);
        return num4;
    }
}
int addStrings(char *str1, char *str2){
	char *result = addStringsHelper(str1, str2);
	log ("Test (%s:%s)", str1, str2);
	if (result) {
		printf("addString of (%s:%s) is %s \n", str1, str2, result);
		free(result);
	}
	return 0;
}

/* Compare two versions like 1.2 , 1.13 and return 1 if version 1 is bigger 
 * and -1 if version1 is smaller or 0 
 */ 
int compareVersion(char* version1, char* version2) {
    int l1 = strlen(version1);
    int l2 = strlen(version2);
    int i =0 , j=0;
    while ((i < l1) || (j<l2)) {
        long long int num1=0, num2=0;
        while ((i<l1)&& version1[i] != '.') {
            num1 += num1*10 + (version1[i] - '0');
            i++;
        }
        while ((j<l2) && version2[j] != '.') {
            num2 += num2*10 + (version2[j] - '0'); 
            j++;
        }
        log("Sum(%lld:%lld) \n",num1,num2);
        if (num1 < num2) 
            return -1;
        else if (num1 > num2)
            return 1;
        if ((version1[i] != '\0') && (version1[i] == '.')) i++;
        if ((version2[j] != '\0') && (version2[j] == '.')) j++;
    }
    
    return 0;
}

/* atoi function convert string to integer 
 https://leetcode.com/problems/string-to-integer-atoi/#/description
 */
int myAtoi(char* str) {
    long long int i =0, len = strlen(str);
    int sign = 1, sum =0;
    
    if (str == NULL)
        return 0;

    while (str[i] != '\0' && str[i] == ' ')
            i++;
    if (str[i] != '\0') {
        if (str[i] ==  '+') {
            sign = 1;
            i++;
        } else if (str[i] == '-')  {
            sign = -1;
            i++;
        }
        while ((str[i] != '\0') && isdigit(str[i])) {
            int n = sum;
            sum = (sum * 10) + (str[i] - '0');
            if (sum/10 != n) {/* number too large or small */
                if (sign < 0)
                    return INT_MIN;
                else
                    return INT_MAX;
            }
            i++;
        }
    
    }

    printf ("atoi(%s) result = %d \n", str, (sign * sum));
    return (0);
}

char isUpper(char s) {
    if (s >= 'A' && s <= 'Z')
        return 1;
    return 0;
}
/* Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.
https://leetcode.com/submissions/detail/180709866/ 
Input: "Hello"
Output: "hello"
*/
char* toLowerCaseHelper(char* str) {
    int len = strlen(str);
    int i = 0;
    char *result = malloc(len * sizeof(char));
    
    if (result == NULL)
        return NULL;
    
    while (i < len) {
        if (isUpper(str[i]))
            result[i] = str[i] - 'A' + 'a';
        else 
            result[i] = str[i];
        i++;
    }
    result[i] = '\0';
    return result;
}
int toLowerCase(char *str) {
	char *result = toLowerCaseHelper(str);
	if (result) {
		printf("lowerCase of (%s) is %s \n", str, result);
		free(result);
	}
	return 0;
}

/* Remove duplicates in a string Eg: "1234555" result-> "12345"*/
void removeDupsHelper(char *str) {
	int len = strlen(str);
	int hash[MAX_ASCII];
	int i, j;

	if (str == NULL || str[0] == '\0')
		return;

	for (i = 0; i < MAX_ASCII; i++)
		hash[i] = -1;
	i = j = 0;
	while (i < len) {
		if (hash[str[i]] != -1 ) { /*skip letter */
			i++;
		} else {
			hash[str[i]] = i; /*save index */
			str[j++] = str[i++];
		}
	}
	if (j != len)
		str[j] = '\0';
}
int removeDups(char *str) {
	char *before = malloc(strlen(str));
	strcpy(before, str);
	removeDupsHelper(str);
	log ("Test (%s:%s)", before, str);
	printf("removeDups of (%s) == %s \n", before, str);
	free(before);
	return 0;
}

/* Wrappers for testType -> function */
typedef int (*fptr1) (char *str1);
typedef int (*fptr2) (char *str1, char *str2);
typedef struct testToRun {
	char *testType;
	int params;
	fptr1 func1;
	fptr2 func2;
	char *descr;
}testRun;

/* testRun tests[] will be used for invoking corresponding tests */
testRun tests[] = {{"multiply", 2, NULL, multiplyStrings, "Multiply s1 with s2"},
	           {"add", 2, NULL, addStrings, "Add s1 and s2"},
	           {"finddiff", 2, NULL, findDifference, "find difference of s1 and s2"},
	           {"compvers", 2, NULL, compareVersion, "compare s1 and s2"},
	           {"isSubseq", 2, NULL, isSubsequence, "is s1 subsequence of s2"},
		   {"removeDups", 1, removeDups, NULL, "remove duplicates in s"},
		   {"atoi", 1, myAtoi, NULL, "convert string s into integer"},
		   {"tolower", 1, toLowerCase, NULL, "convert Uppercases in s to lowerCase"}
		   };

/* Usage function */
static inline void usage(int argc, char *argv[]) {
	testRun *ptr;
	int size = (sizeof(tests) / sizeof(tests[0]));
	for (ptr = tests; ptr != tests + size; ptr++)
		log_err("usage(): %s %s %s <%d arguments> ,description:%s",
			  argv[0], argv[1], ptr->testType, ptr->params, ptr->descr);
}

/* Starting point of string tests*/
void start_stringtest(int argc, char *argv[]) {
	log ("num of arguments %d",argc);
	
	if (argc <= 3) {
		usage(argc, argv);
		return ;
	} 

	bool not_found = true;
	testRun *ptr;
	int tests_size = sizeof(tests) / sizeof(tests[0]) ;
	for (ptr = tests; ptr != tests + tests_size; ptr++) {
		int params = argc - ptr->params;
		if (strcmp(argv[2], ptr->testType) == 0) {
			/* If it has two parameters */
			if ((argc - ptr->params - 3) != 0)
			    break;
			not_found = false;
			if (ptr->params == 1)
				(*ptr->func1)(argv[3]);
			else
				(*ptr->func2)(argv[3], argv[4]);
		}

	}

	if (not_found) {
		usage(argc, argv);
		return;
	}
}
